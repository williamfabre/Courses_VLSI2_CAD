# Description comportemental,vérification,synthèse, placement&routage d'un coprocesseur "CORDIC"
![](https://www-soc.lip6.fr/trac/sesi-tools/)

## I]TP3 : Description comportemental et vérification
### 1.Présentation de l'interface du CORDIC

### 2.Comportement de la MAE

### 3.Verification avec genpat/asimut

### 4.Verification par un testBench (sous Vivado)

## II]TP4 : Synthèse et placement&routage dans la chaine Coriolis2

### Introduction

Dans ce TP, nous réalisons la suite "logique" du design du cordic_core, c'est à dire sa synthèse et son P&R (Placement & Routage).

Pour cela, nous avons pris le design du CORDIC fournis par le professeur car nous n'avions pas finis de tester le notre et de plus cela évite des erreurs induit par un mauvais design alors que le but du TP concerne la synthèse et le P&R et non plus de design d'une architecture.

Nous sommes donc partis des fichiers "cordic_core.vhd" et du couple de fichiers dit "split" que sont "cordic_ctl.vhd" et "cordic_dp.vhd".

Nous avons donc deux approches de synthèse/P&R :

    -- i) synthèse directe de "cordic_core" en mode "press-button". "cordic_core.vhd" est le design complet.
  
    -- ii) synthèse en 2 parties avant P&R; d'où le terme de "split_cordic" en une partie contrôle "cordic_ctl" et une partie DataPath "cordic_dp" (chemin de données ou partie opérative).
 
 Dans le cas (ii) l'avantage est de pouvoir "aider"(aider au sens du résultat) l'outil de P&R en allant faire à la main du "macro-placement" et ainsi obtenir de meilleures résultats que dans la solution (i) qui se résume à du press-button.


### YOSYS : Outil de synthèse

  source_valid(.vhdl) --**Vasy**--> source_valid(.v) --**Yosys**--> source_synth(.blif) --Stratus--> source_placed(?)
  
  Yosys

###

Le coeur du travail a été de traduire à la main le "cordic_dp.vhd" en "cordic_dp.py", qui est un script python faisant appel à un framework du nom de STRATUS (fourni par CORIOLIS). Ce script décrit la netlist du DP.

Pour y parvenir nous avons dans un premier temps tenter une description "bourain". Mais cela nous mettait des battons dans les roues. Nous avons donc repris à zéro en commencant par décrire explicitement (en détail) le DP grâce à l'outil DrawIO. Ainsi tout les noms des NETS et des instances de la partie DP deviennent plus lisible comme vous pouvez le constater ci-dessous :

![]((https://raw.githubusercontent.com/williamfabre/MOCCA/master/tp3/DP.png)


### 5. 

### 6.

### 7.

### 8.

Les commandes fournit par la partie contrôle et utilisé dans la partie données, n'étaient pas adapté !
En effet il était nécéssaire de combiner plusieurs signaux de controle pour les multiplexeurs et additionneurs. Nous avons donc modifié la partie contrôle afin qu'elle s'adapte à la partie données. 

#### Génération du signal nx

Nous avons commencer par décrire l'arbre de multiplexeur que voici : 

![](https://raw.githubusercontent.com/williamfabre/MOCCA/master/tp3/nx_mux_stages.png)

A la suite de cela, nous décrivons le tableau suivant :

| X side          | CMD_n_0 | CMD_n_1_1 | CMD_n_1_0 | CMD_n |
|-----------------|---------|-----------|-----------|-------|
| x               |         |           |           |       |
| x(7)&x&000 0000 |         |           |           |       |
| + xkc           |         |           |           |       |
| - xkc           |         |           |           |       |
| + ykc           |         |           |           |       |
| - ykc           |         |           |           |       |
| + x + y_sra_i   |         |           |           |       |
| + x - y_sra_i   |         |           |           |       |

Ainsi pour chaque ligne nous deffinisons le chemin à travers l'arbre de multiplexeur pour la recopie de l'entrée voulue sur la sortie final.
Nous éclatons les "plus ou moins". Nous ajoutons une colonne identique pour la partie de données sur Y.
Nous remplisons les valeurs que doivent prendre les commandes des multiplexeur. Enfin nous obtenons le tableau suivant :

| Y side          | X side          | CMD_n_0 | CMD_n_1_1 | CMD_n_1_0 | CMD_n | conditions dans la partie contrôle       |
|-----------------|-----------------|---------|-----------|-----------|-------|------------------------------------------|
| y               | x               | 0       | -         | 1         | 0     | put = 1                                  |
| y(7)&y&000 0000 | x(7)&x&000 0000 | 1       | -         | 1         | 0     | init = 1                                 |
| + ykc           | + xkc           | -       | 0         | -         | 1     | place_p = 1 AND Q_p = 0                  |
| - ykc           | - xkc           | -       | 0         | -         | 1     | place_p = 1 AND Q_p = 2                  |
| - xkc           | + ykc           | -       | 1         | -         | 1     | place_p = 1 AND Q_p = 3                  |
| + xkc           | - ykc           | -       | 1         | -         | 1     | place_p = 1 AND Q_p = 1                  |
| + y - x_sra_i   | + x + y_sra_i   | -       | -         | 0         | 0     | calc_p = 1 AND a_lt_0_p = 1              |
| + y + x_sra_i   | + x - y_sra_i   | -       | -         | 0         | 0     | calc = 1 AND calc_p = 1 AND a_lt_0_p = 0 |

Puis nous y ajoutons la dernière colonne qui y apparait déjà, afin de determiner le combinatoire des commandes qui apparaitront dans la description VHDL de la partie controle.

Voivi les commandes :

CMD_n_0   = init;
CMD_n_1_1 = place_p AND quadrant_p(0) 
CMD_n_1_0 = put OR init;
CMD_n     = place_p;

Nous avons soigneusement choisis intrinsequement à chaque multiplexeur les entrées i0 et i1 afin de simplifier les commandes.
De plus, puisque la MAE ne peut être que dans un seul état et que les commandes peuvent prendre dans certains cas des valeurs quelconque (indiquées par "-"), il nous a été possible d'obtenir un combinatire simplifier. Mais aussi en analysant les bits du vecteur Q_p nous avons pu simplifier l'expression de la commande CMD_n_1_1 !

Il est à noter que nous avons pû optimiser le nombre d'entrées qui passe se 8 à 5. Cela en reportant une partie de la commande de cette arbre de multiplexeur sur les additioneurs permettant d'obtenir les valeurs inverses de xkc,ykx et x/y +- y/x_sra_i.

Il est aussi à noter que ces commandes sont réutilisable dans le chemin de données Y !

/users/outil/tasyag/Linux.el7_64/install/share
