# Description comportemental,vérification,synthèse, placement&routage d'un coprocesseur "CORDIC"
![](https://www-soc.lip6.fr/trac/sesi-tools/)

## I]TP3 : Description comportemental et vérification
### 1.Présentation de l'interface du CORDIC

### 2.Comportement de la MAE

### 3.Verification avec genpat/asimut

### 4.Verification par un testBench (sous Vivado)

TODO debuguer le TB

## II]TP4 : Synthèse et placement&routage dans la chaine Coriolis2

https://www-soc.lip6.fr/trac/sesi-tools/
https://www-soc.lip6.fr/master-sesi/ue-mocca/tme-4/

### Introduction

Dans ce TP, nous réalisons la suite "logique" du design du cordic_core, c'est à dire sa synthèse et son P&R (Placement & Routage).

Pour cela, nous avons pris le design du CORDIC fournis par le professeur car nous n'avions pas finis de tester le notre et de plus cela évite des erreurs induit par un mauvais design alors que le but du TP concerne la synthèse et le P&R et non plus de design d'une architecture.

Nous sommes donc partis des fichiers "cordic_core.vhd" et du couple de fichiers dit "split" que sont "cordic_ctl.vhd" et "cordic_dp.vhd".

Nous avons donc deux approches de synthèse/P&R :

    -- i) synthèse directe de "cordic_core" en mode "press-button". "cordic_core.vhd" est le design complet.
  
    -- ii) synthèse en 2 parties avant P&R; d'où le terme de "split_cordic" en une partie contrôle "cordic_ctl" et une partie DataPath "cordic_dp" (chemin de données ou partie opérative).
 
 Dans le cas (ii) l'avantage est de pouvoir "aider"(aider au sens du résultat) l'outil de P&R en allant faire à la main du "macro-placement" et ainsi obtenir de meilleures résultats que dans la solution (i) qui se résume à du press-button.


### YOSYS : Outil de synthèse

  source_valid(.vhdl) --**Vasy**--> source_valid(.v) --**Yosys**--> source_synth(.blif) 
  
  source(.ap/.vst/.vbe)--Stratus_net.py--> result(?)
  source(?)--CGT-->source_placed(?)

#### Press-button du cordic_core

TODO donner les resultats du P&R du press button

### Interface Netlist Layout

#### Netlist

Le coeur du travail a été de traduire à la main le "cordic_dp.vhd" en "cordic_dp.py", qui est un script python faisant appel à la bibliothèque python du nom de STRATUS (fourni par CORIOLIS). Ce script décrit la netlist du DP.

Pour y parvenir nous avons dans un premier temps tenter une description "bourain". Mais cela nous mettait des battons dans les roues. Nous avons donc repris à zéro en commencant par décrire explicitement (en détail) le DP grâce à l'outil DrawIO. Ainsi tout les noms des NETS et des instances de la partie DP deviennent plus lisible comme vous pouvez le constater ci-dessous :

![]((https://raw.githubusercontent.com/williamfabre/MOCCA/master/tp3/DP.png)

Donc, nous reprenons les mêmes noms d'instances et de nets dans le script python.
De plus, nous nous sommes rendus compte qu'il est préférable de déclarer au plus tard les signaux. Soit dès qu'il y en a besoin juste avant la declaration d'une instance ayant besoin de ses entrées, afin de rendre le code plus lisible.

#### Interface

Nous avons eût aussi des problème pour l'interface. En effet les signaux de contrôles proposer n'étaient pas parfait et nécéssiter aussi des opérations logiques avant de pouvoir controler certains multiplexeur. De plus nous avons modifier, ou plutôt alléger les arbres de multiplexeurs que sont ceux des signaux "nx" et "ny". Et donc, nous devions adapter les commandes. 

##### Exemple : Génération du signal nx

Les commandes fournit par la partie contrôle et utilisé dans la partie données, n'étaient pas adapté !
En effet il était nécéssaire de combiner plusieurs signaux de controle pour les multiplexeurs et additionneurs. Nous avons donc modifié la partie contrôle afin qu'elle s'adapte à la partie données. 

Nous avons commencer par décrire l'arbre de multiplexeur que voici : 

![](https://raw.githubusercontent.com/williamfabre/MOCCA/master/tp3/nx_mux_stages.png)

A la suite de cela, nous décrivons le tableau suivant :

| X side          | CMD_n_0 | CMD_n_1_1 | CMD_n_1_0 | CMD_n |
|-----------------|---------|-----------|-----------|-------|
| x               |         |           |           |       |
| x(7)&x&000 0000 |         |           |           |       |
| + xkc           |         |           |           |       |
| - xkc           |         |           |           |       |
| + ykc           |         |           |           |       |
| - ykc           |         |           |           |       |
| + x + y_sra_i   |         |           |           |       |
| + x - y_sra_i   |         |           |           |       |

Ainsi pour chaque ligne nous deffinisons le chemin à travers l'arbre de multiplexeur pour la recopie de l'entrée voulue sur la sortie final.
Nous éclatons les "plus ou moins". Nous ajoutons une colonne identique pour la partie de données sur Y.
Nous remplisons les valeurs que doivent prendre les commandes des multiplexeur. Enfin nous obtenons le tableau suivant :

| Y side          | X side          | CMD_n_0 | CMD_n_1_1 | CMD_n_1_0 | CMD_n | conditions dans la partie contrôle       |
|-----------------|-----------------|---------|-----------|-----------|-------|------------------------------------------|
| y               | x               | 0       | -         | 1         | 0     | put = 1                                  |
| y(7)&y&000 0000 | x(7)&x&000 0000 | 1       | -         | 1         | 0     | init = 1                                 |
| + ykc           | + xkc           | -       | 0         | -         | 1     | place_p = 1 AND Q_p = 0                  |
| - ykc           | - xkc           | -       | 0         | -         | 1     | place_p = 1 AND Q_p = 2                  |
| - xkc           | + ykc           | -       | 1         | -         | 1     | place_p = 1 AND Q_p = 3                  |
| + xkc           | - ykc           | -       | 1         | -         | 1     | place_p = 1 AND Q_p = 1                  |
| + y - x_sra_i   | + x + y_sra_i   | -       | -         | 0         | 0     | calc_p = 1 AND a_lt_0_p = 1              |
| + y + x_sra_i   | + x - y_sra_i   | -       | -         | 0         | 0     | calc = 1 AND calc_p = 1 AND a_lt_0_p = 0 |

Puis nous y ajoutons la dernière colonne (dont le résultat apparait déjà), afin de determiner le combinatoire des commandes qui devront apparaitre dans la description VHDL de la partie controle.

Voivi les commandes extraites du vhdl du cordic_ctl:

CMD_n_0   = init;
CMD_n_1_1 = place_p AND quadrant_p(0) 
CMD_n_1_0 = put OR init;
CMD_n     = place_p;

Nous avons soigneusement choisis, intrinsequement à chaque multiplexeur, les entrées i0 et i1 afin de simplifier les commandes.
De plus, puisque la MAE ne peut être que dans un seul état et que les commandes peuvent prendre dans certains cas des valeurs quelconque (indiquées par "-"), il nous a été possible d'obtenir un combinatire très simplifier. Mais aussi en analysant les bits du vecteur Q_p nous avons pu simplifier l'expression de la commande CMD_n_1_1 !

Il est à noter que nous avons pû optimiser le nombre d'entrées qui passe se 8 à 5. Cela en reportant une partie de la commande de cet arbre de multiplexeur sur les additioneurs permettant d'obtenir les valeurs inverses de xkc,ykx et x/y +- y/x_sra_i.

Il est aussi à noter que ces commandes sont réutilisable dans le chemin de données Y  ormis pour un unique multiplexeur !


#### Layout

Nous avons immédiatement tenter de faire un macro-placement optimisé. Mais celui-ci était naïf. En effet le résultat obtenue fut catastrophique et nous nous en sommes rendus compte après avoir fait le placement proposer dans le sujet que l'on nomera "placement place-right".

Nous sommes partis d'un principe totalement arbitraire mais simple qui est que "toutes les instances consomment la même surface". Ce qui donne le brouillon suivant :

-----------------inclure la fameuse photos !

Nous avons alors encore tenter de rélaiser des macro-placement plus optimiser que le "place-right" mais sans y parvenir. Nous avons donc conclus qu'il est nécéssaire d'avoir une certaine expertise/maitrise sur l'outil STRATUS pour obtenir un résultat optimisé. Et donc par manque de temps nous nous sommes contenter du placement "place-right" pour le P&R "reunuion" de la partie contrôle et DataPath.

### Cordic_net

Il nous faut donc deux interface cohérante entres elles et adapter le script python cordic_net.py. Ensuite nous pouvons le lancer et obtenir un resultat que nous pouvons comparer à celui générer par le "press-button" du "cordic_core.vhd".

TODO lancer le script NET et faire le routage dans CGT
TODO faire une simple comparaison avec le P&R du press-button

### 5. 

### 6.

### 7.

### 8.

/users/outil/tasyag/Linux.el7_64/install/share
